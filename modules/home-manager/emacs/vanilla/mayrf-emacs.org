#+title: GNU Emacs configuration
#+author: mayrf
#+email: 70516376+mayrf@users.noreply.github.com
#+language: en
#+startup: content indent

This is my WIP vanilla Emacs config. The structure and content is heavily copied from Protesilaos Stavrous' [[https://protesilaos.com/emacs/dotemacs][dotemacs config]] and I am very grateful to him for sharing all of his superb Emacs resources with the community.

* Early Init 

#+begin_src emacs-lisp :tangle "early-init.el"
;; (setq package-enable-at-startup nil
;;      inhibit-startup-message   t
;;     frame-resize-pixelwise    t  ; fine resize
;;      package-native-compile    t ; native compile packages
;; )
(scroll-bar-mode -1)               ; disable scrollbar
(tool-bar-mode -1)                 ; disable toolbar
;; (tooltip-mode -1)                  ; disable tooltips
;; (menu-bar-mode -1)                 ; disable menubar
#+end_src

* Init
** Package Manager
*** Elpaca
**** NixOs specific fix
See [[https://github.com/progfolio/elpaca/wiki/Usage-with-Nix][Usage with Nix · progfolio/elpaca Wiki · GitHub]]
#+begin_src emacs-lisp :tangle "init.el"
(defun my/nixos-p ()
  "Return t if operating system is NixOS, nil otherwise."
  (string-match-p "NixOS" (shell-command-to-string "uname -v")))

(defun my/nixos/get-emacs-build-date ()
  "Return NixOS Emacs build date."
  (string-match "--prefix.*emacs.*\\([[:digit:]]\\{8\\}\\)" system-configuration-options)
  (string-to-number (match-string 1 system-configuration-options)))

;; Run this before the elpaca.el is loaded. Before the installer in your init.el is a good spot.
(when (my/nixos-p) (setq elpaca-core-date (list (my/nixos/get-emacs-build-date))))
;;(setq elpaca-core-date (list (my/nixos/get-emacs-build-date)))
#+end_src

**** Installation
#+begin_src emacs-lisp :tangle "init.el"
(defvar elpaca-installer-version 0.8)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil :depth 1
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                  ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                  ,@(when-let* ((depth (plist-get order :depth)))
                                                      (list (format "--depth=%d" depth) "--no-single-branch"))
                                                  ,(plist-get order :repo) ,repo))))
                  ((zerop (call-process "git" nil buffer t "checkout"
                                        (or (plist-get order :ref) "--"))))
                  (emacs (concat invocation-directory invocation-name))
                  ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                        "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                  ((require 'elpaca))
                  ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+end_src

**** Configuration
#+begin_src emacs-lisp :tangle "init.el"
;; Install use-package support
(elpaca elpaca-use-package
  ;; Enable use-package :ensure support for Elpaca.
  (elpaca-use-package-mode))
(setq use-package-always-ensure t)
#+end_src

**** Do not show those confusing warnings when installing packages
#+begin_src emacs-lisp :tangle "init.el"
(add-to-list 'display-buffer-alist
             '("\\`\\*\\(Warnings\\|Compile-Log\\)\\*\\'"
               (display-buffer-no-window)
               (allow-no-window . t)))
#+end_src

** Backup 
By default, Emacs creates automatic backups of files in their original directories, such “file.el” and the backup “file.el~”.  This leads to a lot of clutter, so let’s tell Emacs to put all backups that it creates in the TRASH directory.

#+begin_src emacs-lisp :tangle "init.el"
(setq backup-directory-alist '((".*" . "~/.local/share/Trash/files")))
#+end_src

** auto tangle configuration
#+begin_src emacs-lisp :tangle "init.el"
(defun org-babel-tangle-config ()
  ;; (when (string-equal (buffer-file-name)
  ;; 		      (expand-file-name "~/.config/emacs-vanilla/mayrf-emacs.org"))
  (when (string-match "mayrf-emacs.org" (buffer-file-name))
    (let ((org-config-babel-evaluate nil))
      (org-babel-tangle))))

(add-hook 'org-mode-hook
	  (lambda ()
	    (add-hook 'after-save-hook #'org-babel-tangle-config)))
#+end_src

** Reload config
#+begin_src emacs-lisp :tangle "init.el"

(defun load-directory (dir)
  (let ((load-it (lambda (f)
		   (load-file (concat (file-name-as-directory dir) f)))
		 ))
    (mapc load-it (directory-files dir nil "\\.el$"))))

(defun my/reload-emacs ()
  (interactive)
  ;; (org-babel-tangle "~/.config/emacs-vanilla/mayrf-emacs.org")
  (my/reload-init-el)
  (my/reload-modules))

(defun my/reload-init-el ()
  (load-file "~/.config/emacs-vanilla/init.el"))


(defun my/reload-modules ()
  (interactive)
  (load-directory (locate-user-emacs-file "mayrf-emacs-modules")))
;; (mapc
;;  (lambda (string)
;;    (add-to-list 'load-path (locate-user-emacs-file string)))
;;'("prot-lisp" "prot-emacs-modules"))
;;'("mayrf-lisp" "mayrf-emacs-modules"))
#+end_src

** Load modules

#+begin_src emacs-lisp :tangle "init.el"
  (mapc
   (lambda (string)
     (add-to-list 'load-path (locate-user-emacs-file string)))
   ;;'("prot-lisp" "prot-emacs-modules"))
   '("mayrf-lisp" "mayrf-emacs-modules"))
(require 'mayrf-emacs-keybindings)
(require 'mayrf-emacs-completion)
(require 'mayrf-emacs-style)
(require 'mayrf-emacs-org-mode)
(require 'mayrf-emacs-denote)
(require 'mayrf-emacs-magit)


#+end_src

** Evil mode
 #+begin_src emacs-lisp :tangle "init.el"
(use-package evil
  :ensure t
  :init
  (setq evil-want-integration t) ;; This is optional since it's already set to t by default.
  (setq evil-want-keybinding nil)
  :config
  (evil-mode 1))

(use-package evil-collection
  :after evil
  :ensure t
  :config
  (evil-collection-init))

(use-package evil-nerd-commenter
  :after evil
  :config
  (evilnc-default-hotkeys)
  (define-key evil-normal-state-map "gc" 'evilnc-comment-operator)
  (define-key evil-visual-state-map "gc" 'evilnc-comment-operator))
 #+end_src
 
** Dired
#+begin_src emacs-lisp :tangle "init.el"
(use-package dired-open
  :config
  (setq dired-open-extensions '(("gif" . "sxiv")
                                ("jpg" . "sxiv")
                                ("png" . "sxiv")
                                ("mkv" . "mpv")
                                ("mp4" . "mpv"))))

(use-package peep-dired
  :after dired
  :hook (evil-normalize-keymaps . peep-dired-hook)
  :config
    (evil-define-key 'normal dired-mode-map (kbd "h") 'dired-up-directory)
    (evil-define-key 'normal dired-mode-map (kbd "l") 'dired-open-file) ; use dired-find-file instead if not using dired-open package
    (evil-define-key 'normal peep-dired-mode-map (kbd "j") 'peep-dired-next-file)
    (evil-define-key 'normal peep-dired-mode-map (kbd "k") 'peep-dired-prev-file)
)
#+end_src


** Elfeed

#+begin_src emacs-lisp :tangle "init.el"
;; TODO Setup an use elfeed
(use-package elfeed
  :config
  (setq elfeed-search-feed-face ":foreground #ffffff :weight bold"
        elfeed-feeds (quote
                       (("https://www.reddit.com/r/linux.rss" reddit linux)
                        ("https://opensource.com/feed" opensource linux)))))
(use-package elfeed-goodies
  :init
  (elfeed-goodies/setup)
  :config
  (setq elfeed-goodies/entry-pane-size 0.5))
#+end_src
** template

#+begin_src emacs-lisp :tangle "init.el"
#+end_src

** template

#+begin_src emacs-lisp :tangle "init.el"
#+end_src


** General Settings
*** Visual
#+begin_src emacs-lisp :tangle "init.el"
(global-visual-line-mode t)
(which-key-mode)
#+end_src
*** Navigation
**** Minibuffer ESCAPE
By default, Emacs requires you to hit ESC three times to escape quit the minibuffer.
#+begin_src emacs-lisp :tangle "init.el"
(global-set-key [escape] 'keyboard-escape-quit)
#+end_src
*** Must have settings from System crafters:
https://systemcrafters.net/emacs-from-scratch/the-best-default-settings/
#+begin_src emacs-lisp :tangle "init.el"
    (recentf-mode 1)
      ;; Save what you enter into minibuffer prompts
    (setq history-length 25)
    (savehist-mode 1)
    ;; Remember and restore the last cursor location of opened files
    (save-place-mode 1)

    ;; Move customization variables to a separate file and load it
    ;; Disable the damn thing by making it disposable.
    (setq custom-file (make-temp-file "emacs-custom-"))
    (setq custom-file (locate-user-emacs-file "custom-vars.el"))
    (load custom-file 'noerror 'nomessage)

    ;; Don't pop up UI dialogs when prompting
    ;;(setq use-dialog-box nil)
    ;; Revert buffers when the underlying file has changed
    (global-auto-revert-mode 1)
    ;; Revert Dired and other buffers
    (setq global-auto-revert-non-file-buffers t)

#+end_src

#+begin_src emacs-lisp :tangle "init.el"
#+end_src
*** Themes:
#+begin_src emacs-lisp :tangle "init.el"
  (setq custom-safe-themes t)
  (use-package ef-themes
    :config
    (load-theme 'ef-melissa-dark t nil))
  ;;(load-theme 'ef-melissa-dark)
#+end_src

** PDFs
#+begin_src emacs-lisp :tangle "init.el"
(use-package pdf-tools
  :defer t
  :commands (pdf-loader-install)
  :mode "\\.pdf\\'"
  :bind (:map pdf-view-mode-map
              ("j" . pdf-view-next-line-or-next-page)
              ("k" . pdf-view-previous-line-or-previous-page)
              ("C-=" . pdf-view-enlarge)
              ("C--" . pdf-view-shrink))
  :init (pdf-loader-install)
  :config (add-to-list 'revert-without-query ".pdf"))

(add-hook 'pdf-view-mode-hook #'(lambda () (interactive) (display-line-numbers-mode -1)
                                                         (blink-cursor-mode -1)
                                                         ;; (doom-modeline-mode -1)
							 ))
#+end_src
* Style:
#+begin_src elisp :tangle "mayrf-emacs-modules/mayrf-emacs-style.el" :mkdirp yes
(use-package nerd-icons
  :ensure t)

(use-package nerd-icons-completion
  :ensure t
  :after marginalia
  :config
  (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))

(use-package nerd-icons-corfu
  :ensure t
  :after corfu
  :config
  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

(use-package nerd-icons-dired
  :ensure t
  :hook
  (dired-mode . nerd-icons-dired-mode))

(provide 'mayrf-emacs-style)
#+end_src

* Key-bindings:
#+begin_src elisp :tangle "mayrf-emacs-modules/mayrf-emacs-keybindings.el" :mkdirp yes
(use-package general
  :config
  (general-evil-setup)
  (general-create-definer my/leader
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "SPC" ;; set leader
    :global-prefix "M-SPC") ;; access leader in insert mode
  (my/leader
    "b" '(:ignore t :wk "buffer")
    "bb" '(switch-to-buffer :wk "Switch buffer")
    "bk" '(kill-this-buffer :wk "Kill this buffer")
    "bn" '(next-buffer :wk "Next buffer")
    "bp" '(previous-buffer :wk "Previous buffer")
    "br" '(revert-buffer :wk "Reload buffer"))
  (my/leader
    "o" '(:ignore t :wk "Open")
    "oA" '(org-agenda :wk "Org Agenda"))

  (my/leader
    "f" '(:ignore t :wk "file")
    "ff" 'find-file
    "fP" '((lambda () (interactive) (find-file "~/.config/emacs-vanilla/mayrf-emacs.org")) :wk "Open Config")
    "fr" 'recentf)

  (my/leader
    "h" '(:ignore t :wk "help")
    "hrr" 'my/reload-emacs
    "hy" 'my/reload-emacs
    "hf" '(describe-function :wk "Describe function")
    "hv" '(describe-variable :wk "Describe variable")
    "hk" '(describe-variable :wk "Describe key")))
#+end_src

#+begin_src elisp :tangle "mayrf-emacs-modules/mayrf-emacs-keybindings.el" :mkdirp yes
(provide 'mayrf-emacs-keybindings)

#+end_src

* completion:
#+begin_src elisp :tangle "mayrf-emacs-modules/mayrf-emacs-completion.el" :mkdirp yes
  (use-package vertico
    :ensure t
    :custom
    ;; (vertico-scroll-margin 0) ;; Different scroll margin
    (vertico-count 22) ;; Show more candidates
    ;; (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
    ;; (vertico-cycle t) ;; Enable cycling for `vertico-next/previous'
    :init
    (vertico-mode))
#+end_src

#+begin_src elisp :tangle "mayrf-emacs-modules/mayrf-emacs-completion.el" :mkdirp yes

(use-package orderless
  :ensure t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))

(use-package marginalia
  ;; :hook (after-init . marginalia-mode))
  :config (marginalia-mode))
(provide 'mayrf-emacs-completion)
#+end_src

* Org-mode:
** Variable
#+begin_src elisp :tangle "mayrf-emacs-modules/mayrf-emacs-org-mode.el" :mkdirp yes
(setq org-src-preserve-indentation t)
(setq org-directory "~/Documents/org/")
(setq org-agenda-files (directory-files-recursively org-directory "\\.org$"))
(setq org-inbox-file (file-truename (file-name-concat org-directory "Inbox.org")))
(setq org-tag-alist
      '(;; Places
        ("@home" . ?H)
        ("@work" . ?W)

        ;; Devices
        ("@computer" . ?C)
        ("@phone" . ?P)

        ;; Activities
        ("@planning" . ?n)
        ("@programming" . ?p)
        ("@writing" . ?w)
        ("@creative" . ?c)
        ("@reading" .?b)
        ("@media" .?m)
        ("@listening" .?l)
        ("@email" . ?e)
        ("@calls" . ?a)
        ("@errands" . ?r)))
(setq org-default-notes-file org-inbox-file)
(setq org-capture-templates
   '(("f" "Fleeting note" item
      (file+headline org-default-notes-file "Notes")
      "- %?")
     ("p" "Permanent note" plain
      (file denote-last-path)
      #'denote-org-capture
      :no-save t
      :immediate-finish nil
      :kill-buffer t
      :jump-to-captured t)
     ("t" "New task" entry
      (file+headline org-default-notes-file "Tasks")
      "* TODO %i%?")))
#+end_src
** Keybindings
#+begin_src elisp :tangle "mayrf-emacs-modules/mayrf-emacs-org-mode.el" :mkdirp yes
#+end_src
** Org Babel

#+begin_src elisp :tangle "mayrf-emacs-modules/mayrf-emacs-org-mode.el" :mkdirp yes
(setq org-src-preserve-indentation t)
#+end_src

This goal of this section is to make emacs behave inside src blocks like in the major mode of the language specified by the src block
#+begin_src elisp :tangle "mayrf-emacs-modules/mayrf-emacs-org-mode.el" :mkdirp yes
(setq org-src-tab-acts-natively t)
#+end_src

#+begin_src elisp :tangle "mayrf-emacs-modules/mayrf-emacs-org-mode.el" :mkdirp yes
(provide 'mayrf-emacs-org-mode)
#+end_src
** org-caldav
#+begin_src elisp :tangle "mayrf-emacs-modules/mayrf-emacs-org-mode.el" :mkdirp yes
* Denote:
#+begin_src elisp :tangle "mayrf-emacs-modules/mayrf-emacs-denote.el" :mkdirp yes
(use-package denote
  :after org
  :config
  (setq denote-directory (file-truename (file-name-concat org-directory "Denotes/")))

  )
(with-eval-after-load 'org-capture
  (add-to-list 'org-capture-templates
               '("N" "New note with no prompts (with denote.el)" plain
		 (file denote-last-path)
		 (function
                  (lambda ()
                    (denote-org-capture-with-prompts nil nil nil)))
		 :no-save t
		 :immediate-finish nil
		 :kill-buffer t
		 :jump-to-captured t))
  (add-to-list 'org-capture-templates
               '("j" "Journal" entry
                 (file denote-journal-extras-path-to-new-or-existing-entry)
                 "* %U %?\n%i\n%a"
                 :kill-buffer t
                 :empty-lines 1)))
(defun my-denote-region-org-structure-template (_beg _end)
  (when (derived-mode-p 'org-mode)
    (activate-mark)
    (call-interactively 'org-insert-structure-template)))

;; TODO Maybe also add a link to the source?
(add-hook 'denote-region-after-new-note-functions #'my-denote-region-org-structure-template)


;; Variant of `my-denote-region' to reference the source

(defun my-denote-region-get-source-reference ()
  "Get a reference to the source for use with `my-denote-region'.
The reference is a URL or an Org-formatted link to a file."
  ;; We use a `cond' here because we can extend it to cover move
  ;; cases.
  (cond
   ((derived-mode-p 'eww-mode)
    (plist-get eww-data :url))
   ;; Here we are just assuming an Org format.  We can make this more
   ;; involved, if needed.
   (buffer-file-name
    (format "[[file:%s][%s]]" buffer-file-name (buffer-name)))))

(defun my-denote-region ()
  "Like `denote-region', but add the context afterwards.
For how the context is retrieved, see `my-denote-region-get-source-reference'."
  (interactive)
  (let ((context (my-denote-region-get-source-reference)))
    (call-interactively 'denote-region)
    (when context
      (goto-char (point-max))
      (insert "\n")
      (insert context))))

;; Add quotes around snippets of text captured with `denote-region' or `my-denote-region'.

(defun my-denote-region-org-structure-template (beg end)
  "Automatically quote (with Org syntax) the contents of `denote-region'."
  (when (derived-mode-p 'org-mode)
    (goto-char end)
    (insert "#+end_quote\n")
    (goto-char beg)
    (insert "#+begin_quote\n")))

(add-hook 'denote-region-after-new-note-functions #'my-denote-region-org-structure-template)

(defun file-to-string (file)
  "File to string function"
  (with-temp-buffer
    (insert-file-contents file)
    (buffer-string)))
(defun my-weekly-review-template ()
  ;; (interactive)
        (file-to-string "~/Documents/org/gtd/templates/weekly_review.txt"))
        ;; (file-to-string((file-truename (file-name-concat org-directory "gtd/templates/weekly_review.txt")))))

(setq denote-templates '((weekly_review . my-weekly-review-template)))

;; (message (file-to-string "~/Documents/org/gtd/templates/weekly_review.txt"))

#+end_src

#+begin_center

#+end_center

#+begin_src elisp :tangle "mayrf-emacs-modules/mayrf-emacs-denote.el" :mkdirp yes
(provide 'mayrf-emacs-denote)
#+end_src

* Magit:
#+begin_src elisp :tangle "mayrf-emacs-modules/mayrf-emacs-magit.el" :mkdirp yes
(use-package magit
  :after general
  :general (my/leader "gg" 'magit))
#+end_src

#+begin_src elisp :tangle "mayrf-emacs-modules/mayrf-emacs-magit.el" :mkdirp yes
(provide 'mayrf-emacs-magit)
#+end_src
